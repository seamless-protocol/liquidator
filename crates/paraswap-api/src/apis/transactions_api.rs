/*
 * ParaSwap API v5
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@paraswap.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use tracing::debug;
use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`transactions_network_post`]
#[derive(Clone, Debug, Default)]
pub struct TransactionsNetworkPostParams {
    /// ID of the network. (Mainnet - 1, Ropsten - 3, Polygon - 56, BSC - 137).
    pub network: i32,
    /// Checkout `schemas/TransactionsRequestPayload` to infer what parameters are required to be parsed in the responseBody. (<b>Note</b>: The priceRoute object should be directly parsed without any change.)
    pub transactions_request_payload: crate::models::TransactionsRequestPayload,
    /// The set gas-price for the transaction in wei.
    pub gas_price: Option<String>,
    /// Allows the API to skip performing onchain checks such as balances, allowances, as well as transaction simulations. <b>Note:</b> The response does not contain <b><u>gas</u></b> parameter when <i>ignoreChecks</i> is set to `true`. 
    pub ignore_checks: Option<bool>,
    /// Allows the API to skip gas checks <b>Note:</b> The response does not contain <b><u>gas</u></b> parameter when <i>ignoreGasEstimate</i> is set to `true`.
    pub ignore_gas_estimate: Option<bool>,
    /// Allows the API to return the contract parameters only.
    pub only_params: Option<bool>
}


/// struct for typed errors of method [`transactions_network_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsNetworkPostError {
    Status400(crate::models::TransactionsError),
    UnknownValue(serde_json::Value),
}


pub async fn transactions_network_post(configuration: &configuration::Configuration, params: TransactionsNetworkPostParams) -> Result<crate::models::InlineResponse2001, Error<TransactionsNetworkPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let network = params.network;
    let transactions_request_payload = params.transactions_request_payload;
    let gas_price = params.gas_price;
    let ignore_checks = params.ignore_checks;
    let ignore_gas_estimate = params.ignore_gas_estimate;
    let only_params = params.only_params;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/transactions/{network}", local_var_configuration.base_path, network=network);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = gas_price {
        local_var_req_builder = local_var_req_builder.query(&[("gasPrice", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ignore_checks {
        local_var_req_builder = local_var_req_builder.query(&[("ignoreChecks", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ignore_gas_estimate {
        local_var_req_builder = local_var_req_builder.query(&[("ignoreGasEstimate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = only_params {
        local_var_req_builder = local_var_req_builder.query(&[("onlyParams", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    local_var_req_builder = local_var_req_builder.json(&transactions_request_payload);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        debug!("transactions_network_post local_var_content {:?}", local_var_content);
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TransactionsNetworkPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

