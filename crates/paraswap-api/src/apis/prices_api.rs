/*
 * ParaSwap API v5
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@paraswap.io
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use tracing::debug;
use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`prices_get`]
#[derive(Clone, Debug, Default)]
pub struct PricesGetParams {
    /// Source Token Address or Token Symbol (for tokens from /tokens).
    pub src_token: String,
    /// Destination Token Address or Token Symbol (for tokens from /tokens).
    pub dest_token: String,
    /// Amount in the Denomination of Source Token
    pub amount: String,
    /// Side of the swap.
    pub side: SwapSide,
    /// Source Token Decimals; can be omitted if Symbol is provided for `srcToken`.
    pub src_decimals: Option<i32>,
    /// Destination Token Decimals; can be omitted if Symbol is provided for `destToken`.
    pub dest_decimals: Option<i32>,
    /// ID of the blockchain network.
    pub network: Option<i32>,
    /// _If provided_, **others** object is filled in the response with price quotes from other exchanges (if available for comparison).
    pub other_exchange_prices: Option<bool>,
    /// Comma Separated List of DEXs to include without spaces.
    pub include_dexs: Option<Vec<crate::models::Dexs>>,
    /// Comma Separated List of DEXs to exclude without spaces.
    pub exclude_dexs: Option<Vec<crate::models::Dexs>>,
    /// Comma Separated List of Contract Methods to include without spaces.
    pub include_contract_methods: Option<Vec<crate::models::ContractMethod>>,
    /// Comma Separated List of Contract Methods to exclude without spaces.
    pub exclude_contract_methods: Option<Vec<crate::models::ContractMethod>>,
    /// User Wallet Address.
    pub user_address: Option<String>,
    /// Dash (-) separated list of tokens (addresses or symbols from /tokens) to comprise the price route. Max 4 tokens
    pub route: Option<String>,
    /// partner string
    pub partner: Option<String>
}

#[derive(Clone, Copy, Default, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SwapSide {
    #[serde(rename = "SELL")]
    #[default]
    Sell,
    #[serde(rename = "BUY")]
    Buy,
}

impl ToString for SwapSide {
    fn to_string(&self) -> String {
        match self {
            Self::Sell => String::from("SELL"),
            Self::Buy => String::from("BUY"),
        }
    }
}

/// struct for typed errors of method [`prices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PricesGetError {
    Status400(crate::models::InlineResponse400),
    UnknownValue(serde_json::Value),
}


pub async fn prices_get(configuration: &configuration::Configuration, params: PricesGetParams) -> Result<crate::models::InlineResponse200, Error<PricesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let src_token = params.src_token;
    let dest_token = params.dest_token;
    let amount = params.amount;
    let side = params.side;
    let src_decimals = params.src_decimals;
    let dest_decimals = params.dest_decimals;
    let network = params.network;
    let other_exchange_prices = params.other_exchange_prices;
    let include_dexs = params.include_dexs;
    let exclude_dexs = params.exclude_dexs;
    let include_contract_methods = params.include_contract_methods;
    let exclude_contract_methods = params.exclude_contract_methods;
    let user_address = params.user_address;
    let route = params.route;
    let partner = params.partner;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/prices", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("srcToken", &src_token.to_string())]);
    if let Some(ref local_var_str) = src_decimals {
        local_var_req_builder = local_var_req_builder.query(&[("srcDecimals", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("destToken", &dest_token.to_string())]);
    if let Some(ref local_var_str) = dest_decimals {
        local_var_req_builder = local_var_req_builder.query(&[("destDecimals", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("amount", &amount.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("side", &side.to_string())]);
    if let Some(ref local_var_str) = network {
        local_var_req_builder = local_var_req_builder.query(&[("network", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = other_exchange_prices {
        local_var_req_builder = local_var_req_builder.query(&[("otherExchangePrices", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_dexs {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("includeDEXS".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("includeDEXS", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_dexs {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeDEXS".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeDEXS", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = include_contract_methods {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("includeContractMethods".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("includeContractMethods", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_contract_methods {
        local_var_req_builder = match "csv" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("excludeContractMethods".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("excludeContractMethods", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = user_address {
        local_var_req_builder = local_var_req_builder.query(&[("userAddress", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = route {
        local_var_req_builder = local_var_req_builder.query(&[("route", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = partner {
        local_var_req_builder = local_var_req_builder.query(&[("partner", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        debug!("prices_api local_var_content {:?}", local_var_content);
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PricesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

